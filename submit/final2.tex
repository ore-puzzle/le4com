\documentclass{jarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\usepackage{listings}

\begin{document}

\title{最終レポート}
\author{1029289895 尾崎翔太}
\date{2018/11/22}

\maketitle
\newpage

\section{課題8}
\subsection{プログラムの設計方針}
基本的には末永先生の教科書通りになっている. 教科書にないものについては実験のページに書いてある通りにした. そのため, 設計方針について特筆すべきことはない.
\subsection{プログラムの説明}
vm.mlに定義されている関数のいくつかについて説明する.
\begin{description}
\item[gather\_id\_from\_exp関数(99～115行目)] \leavevmode \\
exp中の変数のidを集める関数である. 最早自由変数は存在しないので, LetExpとLoopExpのみに注目すればよい. さらに, 同名の変数はリネームしてあるので重複もない. 集めた変数は関数δを構築するために使われる.
\item[make\_delta関数(119～131行目)] \leavevmode \\
関数δを構築する関数である. 引数はParamと, 変数はLocalと関連付けていく. ただし, Localは関数の返り値を格納するものをt0とするため, indexは1からとする. 最後にList.assoc関数を仕込むことで関数δが完成する.
\item[fresh\_label関数(134～142行目)] \leavevmode \\
IfExpやLoopExpの変換のためにフレッシュなラベルを得る関数である. 中身は実験3のfresh\_tyvar関数をまねている.
\item[trans\_value関数(148～152行目)] \leavevmode \\
Flat.valueを変換する関数である. Varはdeltaにより適切な格納領域に変換される.
\item[trans\_cexp関数(159～188行目)] \leavevmode \\
Flat.cexpを変換する関数である. 教科書通りである. loop\_varとlblはtrans\_exp関数のための引数である. 
\item[trans\_exp関数(193～213行目)] \leavevmode \\
Flat.expを変換する関数である. CompExpとLetExpは教科書通りである. LoopExpはLetExpに似ているが, ラベルを生成していたり, delta関数を二回呼んでいたりしている部分が違う. これらの情報はRecurExpを変換するのに必要となるため, trans\_exp関数はこれらも引数に取るようになっている. RecurExpはそれらの情報から, 更新された値をどこに格納するか, そしてどこにジャンプするかを決める.
\end{description}
\subsection{感想}
基本的に教科書通りに実装することができた. ここまではtrans\_value関数みたいな関数は関数内関数ではなくて, 外に置いていたが, 今回はproc\_nameが欲しかったので中に置くことになり, 微妙に一貫性が取れていない. loop\_varやlblみたいな, 一部でしか使わない値を引数として持ちまわるのは正しいのかどうか, いまだによくわかっていない. いずれにせよ, 教科書のおかげで実装方針が明確だったので, そこまで苦労しなかった.


\section{課題9}
\subsection{プログラムの設計方針}
実験のページに載っている部分はそのまま実装した. 載っていない部分として, ARMにおける即値の取り扱いがある. 調べたところ, ARMの即値は8ビットの値をローテートシフトを行うことで生成しているようだ. したがって, 例えば277(100010101)のように, 1が立っている範囲が8ビットに収まっていないとエラーが出る. そのかわりに, ldrの第二引数に=プレフィックスをつけることで定数のロードができるようである. ゆえに, 仮想機械コードをARMアセンブリコードに変換した後で, ARMで取り扱えない即値があるならldr命令を用いたものに置き換えるということをする.
\subsection{プログラムの説明}
arm\_noreg.mlに定義されている関数のいくつかについて説明する.
\begin{description}
\item[make\_instr\_of\_malloc関数(43～55行目)] \leavevmode \\
Mallocにおいて値をヒープ領域に格納する命令列を生成する関数である. ヒープ領域の先頭アドレスを保持しているレジスタがA1であることを仮定しており, A1にmem\_accessしている. ただし, 格納したい値がmymallocを呼ぶ前のA1に入っていた場合は, それを一旦退避先から適当なレジスタに読みだして格納している.
\item[to\_binary\_str関数(58～67行目)] \leavevmode \\
int型の値を2進数表示のstring型の値に変換する関数である. 具体的には, 0か1のみが格納されているリストで, 引数の2進表現を行って, stringにマップし, fold\_leftで結合している. この関数はimm\_to\_ldr関数で用いられる.
\item[get\_max\_range関数(70～76行目)] \leavevmode \\
与えられた2進数(string型)の一番左の1と一番右の1との間隔を返す関数. string型で与えられているので, 簡単に求めることができる. ただし, すべて0の場合のエラー処理には注意しなければならない. この関数はimm\_to\_ldr関数で用いられる.
\item[imm\_to\_ldr関数(81～100行目)] \leavevmode \\
不適切な即値を用いているMov, Add, Cmpをldrを使ったものに変換する関数である. MovはそのままLdrに変換して, Add, Cmpは一旦A4にldrしてから演算している. また, =プレフィックスをつけるために, 意味的には不適切だが, addrのLコンストラクタを用いている. 引数がリストの形をしているのは, 一つの命令を二つの命令に変換するためである.
\item[gen\_instr関数(109～165行目)] \leavevmode \\
実際に変換を行う関数である. 実験のページの変換そのものである.
\item[gen\_decl関数(107～180行目)] \leavevmode \\
命令列を生成する関数である. 167行目は, gen\_instr関数を用いて仮想機械コードをARMアセンブリコードにマップして(stmt list list), concatして(stmt list), その要素一つ一つをそれだけからなるリストにマップして(stmt list list), imm\_to\_ldr関数でマップして(stmt list list), concatしている(stmt list). imm\_to\_ldr関数は命令数を変えうる変換をするので, わざわざリストのリストにしている.
\end{description}
\subsection{感想}
実験のページに変換方法がほぼ全て書いてあったのでとても簡単だった. 一方で, mymallocは引数を一つしか取らないが, A2もちゃんと退避しなければならなかったり, ARMの即値の仕様が複雑だったりと, わかりづらい落とし穴だらけで, できたと思うところまでは楽だが, 後になって原因不明のバグに苦しめられる部分だったと思った.


\section{課題11}
\subsection{前置き}
到達定義解析のみを行った. 
\subsection{プログラムの設計方針}
コンパイラの講義スライドの内容をlive.mlをまねて実装した. プロパティは変数とそれが定義された行番号ということだったので, 行番号に相当するものを得るためにcfgを受け取ることにした. また, 変数はリネームしてあり同名の変数を複数回定義するのはループの場合だけなので, kill関数は存在しない. 
\subsection{プログラムの説明}
reachableDef.mlに定義されている関数のいくつかを説明する.
\begin{description}
\item[get\_second\_list関数(35～38行目)] \leavevmode \\
二要素の組からなるリストから, 第二要素のみからなるリストを作る関数である. 受け取ったcfgは, 実は関数名とcfgの組になっているので, いらない関数名を捨てるための関数である.
\item[transfer関数(43～55行目)] \leavevmode \\
伝達関数である. gen関数は, 変数に値を格納する命令の場合に, その変数のidとその命令のcfg中での位置の組を生成する. 上で述べたように, 同じ変数を複数回定義するのはループの場合のみで, その場合も再定義した直後にループの先頭という, 元の定義も到達しうる場所に戻るので, kill関数は必要ない.
\end{description}
\subsection{感想}
MiniMlが関数型言語であることと, 正規化の段階で変数名の付け替えを行ったことが幸いして, かなり単純になっている. 難しいのは解析そのものではなく, スライドの行番号にあたるものをどうやって得るかであった. ここまでできるだけ参照は使わないようにしていたのだが, cfgを利用するための他の方法が思いつかなかったので泣く泣く参照を使用した.

\section{課題12}
\subsection{プログラムの設計方針}
実験のページにあるように干渉グラフを用いてレジスタ割り付けをすることにした. 干渉グラフの彩色については, いわゆる貪欲法を採用した. つまり, 頂点を何らかの順で並べておき, その順に色を塗っていく. 色は0, 1, 2, ・・・, で表されていて, 今塗ろうとしている頂点に隣接している頂点に使われていない色の中で, 最も値が小さい色を塗るという方法だ. 頂点の順番は次数によるのがよいことは明らかだが, 昇順と降順のどちらにするかは思想による. 今回は, できるだけ多くの変数をレジスタに割り当てるということだったので, 次数の大きい頂点(多くの変数と共に生存している変数)がレジスタに居られると邪魔であるから, 昇順にすることにした. こうして色を塗ったあとで, 実際に使えるレジスタの数番目の色までをレジスタに, それ以降の色をローカル領域に割り当てた. コード生成については, Mallocの第二要素の要素がローカル領域に割り付けられている場合に, Mallocをさらに細分化しないと実装できないので, MallocをMallocとAssignの二つに分割した. Mallocではヒープ領域の確保のみを行って, Assignで格納していく. 他には, ローカル領域からの読み出しに用いたりする一時レジスタとしてreserved\_regを使用した. また, 関数呼び出しの際にレジスタを退避する必要があるが, すべてのレジスタを退避するのではなく, 本当に対比しなければならないレジスタのみを退避している. 最後に, どうしてもレジスタが足りない場合のために, ローカル領域に一つだけ退避する場所を作った.
\subsection{プログラムの説明}
reg.mlに定義されている関数のいくつかを説明する.
\begin{description}
\item[get\_properties\_as\_list関数(165〜172行目)] \leavevmode \\
すべての命令の前後のプロパティをまとめてリストとして得る関数である. Dfa.get\_property関数を呼んで結合していくだけだが, ラベルにはプロパティがないことだけ注意する必要がある.
\item[trans\_props\_from\_op\_to\_id関数(175〜181行目)] \leavevmode \\
プロパティにはParamとLocalがあるのだが, Paramは捨ててLocalにぶら下がっているidを取り出す関数である. レジスタ割り付けにパラメータの情報は必要なく, どのLocalが生存しているかが重要なので, いちいちLocalからidを取り出すのも面倒だという要望を叶えるのに用いる. ただし, プロパティには不動点反復を回すためのdummyが紛れているので, それも弾くようにしている.
\item[make\_adjacency\_matrix関数(185〜216行目)] \leavevmode \\
隣接行列を作る関数である. まず, 大きさがVmにおける局所変数の数で, すべての要素が0の正方行列を表す配列を作る(idの値がそのまま行, 列に対応している). そして, 変数の生存情報を見ながら行列を更新していく. outer\_loopでは生存している変数の集合を順に取り出してinner\_loopへ渡していく. inner\_loopでは, 先頭の要素を取り出して, 残りの要素たちと行列において交わる部分の値を1に更新していく. また, MallocがMallocとAssignに分かれたことによる干渉は当然生存変数解析で解析されていないので, ここで行っている. 
\item[get\_max関数(246〜250行目)] \leavevmode \\
リスト中の最大値を返す関数である. この関数はある頂点に隣接している頂点に塗られている色の最大値を求めるために用いる. その頂点には返り値+1の色を塗れば良いのだ. こうすると, 例えば周りの頂点の色が0と2だったら1ではなく3を塗ってしまうではないかと思われるが, 塗ろうとしているのは一般のグラフではなく干渉グラフで, かつ次数でソートしてあるため, そのようなことは起こらない.
\item[map\_property関数(283〜290行目)] \leavevmode \\
プロパティを割り付けの結果にマップする関数(Paramとローカル領域に割り付けられたものは無視)である. 今使われているレジスタを知りたい時に用いる.
\item[get\_max\_tmp関数(293〜302行目)] \leavevmode \\
各関数呼び出しにおいて退避すべきレジスタの数, の最大値を返す関数である. 退避のためのローカル領域の大きさを得るために用いる.　関数呼び出し(Call)の直後で生存しているレジスタから, その返り値が格納されるレジスタを除いたものが退避すべきレジスタであるから, その数を見ていけばよい.
\item[make\_regs関数(312〜319行目)] \leavevmode \\
汎用レジスタのリストを返す関数である. 今使用可能なレジスタを得るために全体集合のようなものが必要だったので定義した.
\item[paint関数(325〜338行目)] \leavevmode \\
頂点に色を塗っていく関数である. 一つずつ頂点を見ていくためにあるのがnow\_node\_colorで, 隣接している頂点の色を知るために頂点全体を保持しているのがnode\_colorである. 隣接行列の対応する行を取り出して, その情報から隣接している頂点がわかるので, それらの頂点の色を集めて, dummy(-1)を加えたものの最大値+1の色で塗る. node\_colorも更新していく.
\item[make\_map関数(341〜355行目)] \leavevmode \\
塗られた頂点から, 実際にレジスタ割り付けを行っていく関数である. 塗られた色が汎用レジスタの数より小さければレジスタに, そうでなければローカル領域に割り付ける. 返り値には, そうしてできたマップの他に, 必要なローカル領域の数も含まれる. 一つでもローカル領域に割り付けられた場合は, 退避のために追加で一つローカル領域を確保する. 実際には,　ローカル領域に割りつけられたものが一つだけなら退避のための領域は必要ないのだが, その後の処理を簡単にするために一つだけの場合も退避する領域を確保している.
\item[make\_call\_instr関数(364〜502行目)] \leavevmode \\
Callを変換する関数である. Callは場合分けしなければならない引数が実質3つある上に, さらにそれぞれの場合の中でも場合分けがあるので大量の場合分けが発生している. 関数化しようにも, 部分部分のコード量は少ないのに微妙に異なっていることが多いので, コード量はあまり減りそうになかった. 場合分けが多いだけで, それぞれの場合でしていることは単純なので,　丁寧に追っていくと理解するのは難しくないと思う. 基本的に, reserved\_reg, 空いているレジスタ, 退避したレジスタの順に利用していく. 空いているレジスタと退避したレジスタの関係から, 空いているレジスタがないときは必ず退避したレジスタがあるので上手くいくようになっている.
\item[trans\_instr関数(506〜597行目)] \leavevmode \\
実際にコードを変換する関数である. 基本的にはreserved\_regを用いてローカル領域の読み書きを行っている. BinOpはmake\_call\_instr関数のように場合分けを列挙しても良かったのだが, 上手くまとめてみたかったのでこういう形になった. ローカル領域に作った退避のための空間が使われ得るのはBinOpの場合だけである. 
\item[trans\_intstrs関数(601〜613行目)] \leavevmode \\
順番にtrans\_instr関数を呼んでいく関数である. List.map関数を用いずに再帰関数で書いているのは, available\_regを求めるために, 変換しようとしている命令の直前のプロパティが必要だからである.
\end{description}
\subsection{感想}
グラフ彩色の方針は簡単に定まったが, それを実装するのに苦労した. グラフの部分はもっと汎用なものにして別ファイルにまとめようかと思ったが, この実験では他に使わないので, 面倒くさくなって, 結局この課題にべったり依存した形になった. 変換の部分は, 本質的には単純だが, とにかく場合分けが多くて大変だった. BinOpも最初はCallのように場合分けを列挙していたのだが, 上手くまとめる方法を模索している内にああなった. 正直場合分けを列挙している方がわかりやすい気がする. ここまで場合があると, すべての場合に正しく動作していることを確認するのは相当大変だと思った. 実際私はしていない.　また, Mallocについては, 元の仕様より私の仕様の方が自然だと思うのだがどうなのでしょうか. それと, MallocとReadだけdestを用いている(Assignもそれにならった)理由がよくわからなかった. メモリからメモリに移動させる命令でもあれば話は違うのだが.　更に上を目指すなら, この段階ではレジスタ割り付けをしてどれだけのローカル領域か必要かだけを得て, コード自体はレジスタが無限にあるとして,　ローカル領域のやりとりはすべてARMアセンブリコードを吐くところでやった方が, 見えているレジスタの数が違うので, より良くなると思った.


\section{課題13}
\subsection{プログラムの設計方針}
やることはレジスタ割り付けなしの場合とほとんど同じなので, 基本方針も同じである. 違う点として, 即値を読みだすレジスタをどうするかというものがあるが, A3を使うことにした. また, いくつかの場合で, さらに一時レジスタが欲しくなったときは, A4を使うことにした.
\subsection{プログラムの説明}
arm\_reg.mlに定義されている関数の一つを説明する.
\begin{description}
\item[gen\_instr関数(111〜207行目)] \leavevmode \\
実際にコードを生成する関数である. 基本的にはarm\_noreg.mlにあるものと同じである. 大きく違うのは, BinOpとMalloc, Assignである. BinOpはaddrとして即値も取るようになったので, そこで場合分けをしている. 例外として, Multの第二引数が即値だった場合は一旦A4に読みだしていたり, Cmpの非可換性から値をA3に読みだしたりしている. 実は最適化によりliは要らないのだが, 必ずしも最適化するわけではないので残している. Mallocについては, mymallocを呼び出して返り値を格納すべき場所に格納するまでを行い, そのヒープ領域に値を格納していくのはAssignで行っている. その際, destがローカル領域に割り付けられていた場合はAssignのたびに読みだしている.
\end{description}
\subsection{感想}
BinOpが意外とややこしい感じになってしまった. これもあまり変に共通部分をまとめずに, Add, Mult, Cmpで始めに場合分けをした方が見通しが良かったかもしれない. Malloc/Assignについてはレジスタ割り付けなしの場合のように, A1にポインタがあると仮定して, 第一引数を格納したい場合だけ例外処理をしたかったが, Assignがいつ終わるかわからないと, 退避したA1とA2を書き戻せないのでできなかった. 実はこれを実現するためにgen\_instr関数をList.map関数ではなく, 再帰関数で呼び出すようにしようと思っていたのだが, 今の今まで忘れていた.


\section{課題14}
\subsection{プログラムの設計方針}
(a), (b), (c)すべて行った. アイデア自体はコンパイラのスライドそのものである. コピー伝搬は, (到達可能コピー解析ができていないので)到達可能定義解析から, 使われようとしている変数の定義がParam, あるいはLocalのMoveだった場合に置き換えることで実装している. 解析結果はcfgにおける位置情報なので, cfgそのものも受け取る必要がある. 伝搬させていくためには, 置き換えた場合に, cfgの方の命令も置き換えたものに変えていく必要があるのでそうしている. 定数畳み込みは, コピー伝搬と同様の考えで, Param, Localの部分がProc, IntVになっただけである. ただし, BinOpはもう一歩踏み込んで, 未知変数一つと定数二つが同じ演算子で結ばれている場合も計算するようになっている. また, 畳み込みは一つずつ行われる. 定数の畳み込みが終わったあとで, if文が除去できるなら除去している. したがって, 定数畳み込みは複数回行うことを想定している. 不要代入文削除は, 生存変数解析から, 定義された直後に生存していない変数を定義している文を除去している. これらの最適化を, コード変化しなくなるまでずっと順に適用していく. 
\subsection{プログラムの説明}
\subsubsection{定数畳み込み}
constantFolding.mlに定義されている関数のいくつかを説明する.
\begin{description}
\item[judge関数(8〜11行目)] \leavevmode \\
BranchIfの第一要素のopを受け取って, 条件式の評価をする関数である. opがIntVなら0より大きいか否かでthen節に行くかelse節に行くかがわかり, それに対応したtri\_bool型の値を返す. opがIntVでないならまだ判定できないのでUを返す.
\item[get\_subset関数(14〜18行目)] \leavevmode \\
プロパティからopを定義している部分を取り出す関数である. 当然opがLocalでなければ空リストを返す.
\item[get\_another\_label関数(22〜26行目)] \leavevmode \\
BranchIfの第二要素のラベルから, 対応するもう一つのラベルを得る関数である. BranchIfを削除する際にBranchIfが直接保持はしていないラベルを知る必要があるので, そのために用いる. 求めたいラベルは受け取ったラベルの末尾の数字をプラス1したものなので, 上手くそこをintに変換して1を加えてstringに戻して結合している.
\item[update関数(29〜31行目)] \leavevmode \\
定数畳み込みによる更新をcfgに対して行う関数. 更新前の命令からcfgにおける位置を求めて, その位置を新しい命令に置き換えている.
\item[fold関数(52〜223行目)] \leavevmode \\
実際に定数畳み込みを行う関数. 基本的に, get\_subst関数を用いて, プロパティからopに関する部分を取り出して, その要素が一つでないなら何もしない. 一つならその値からopが定義された部分を見に行って, それがIntVやProcでないなら, 何もしない. IntVやProcならMoveでその値を代入する文に置き換えるということをする. BinOpについては, オペランドの一方の定義がIntVで, もう一方の定義がBinOpだった場合, そのBinOpのオペランドまで確認して, 未知変数一つと定数二つが同じ演算子でつながれている状況なら, 定数二つを畳み込む. Readについては, opが直接Mallocによって定義されている場合は, そのMallocの第二要素であるリストのi番目の要素が定数ならそれに置き換える.
\item[eliminate\_then関数, eliminate\_else関数(226〜249行目)] \leavevmode \\
定数畳み込みの結果, BranchIfを削除する場合にthen節を削除したり, else節を削除したりする関数である. 削除したいBranchIfに関する二つのラベルとそのBranchIf以降の命令列を受け取るので, then節を削除する場合は片方のラベルからもう片方のラベルまでをすべて削除し, else節を削除する場合は片方のラベルまでのすべてと, もう片方のラベルを削除する.
\item[eliminate\_branchIf関数(252〜265行目)] \leavevmode \\
BranchIfが削除できるかどうかを判定し, できるなら削除する関数である. BranchIfに関数もう一つのラベルを求めて,　judge関数で削除できると判定できた場合はeliminate\_XXX関数で対応した方を削除する.
\item[fold\_const関数(263〜265行目)] \leavevmode \\
定数畳み込みをするために外から呼ばれる関数である. 特筆すべきことは, fold関数でマップしてからeliminate\_branchIf関数を呼んでいることである.　すなわち, BranchIfを削除することによって新たに定数畳み込みが行えるようになっても, もう一度解析してfold\_const関数が呼ばれないとその部分の畳み込みは行われない.
\end{description}
\subsubsection{コピー伝搬}
コピー伝搬に関する関数はcopyPropagation2.mlに定義されている. 内容はconstantFolding.mlに定義されている関数の, IntVとProcの部分をParamとLocalに変えたものとほとんど同じなので説明しない. 大きく違うのはBinOpの場合だが, constantFolding.mlのものよりもかなり単純なものになっている.
\subsubsection{不要代入文削除}
deadCodeElimination.mlに定義されている関数の一つを説明する.
\begin{description}
\item[eliminate\_dead\_code関数(5〜16行目)] \leavevmode \\
実際に不要な代入文を削除する関数である. やっていることは至極単純で, 全命令を再帰関数で順に見ていき, その命令が変数を定義するものの場合は, その直後に定義した変数が生存しているかどうかを確認し, 生存しているなら何もせず, 生存していないなら取り除く.
\end{description}
\subsubsection{最適化全体}
最適化を行っている部分はopt.mlに定義されている. 上の三つの最適化をコピー伝搬, 定数畳み込み, 不要代入文削除の順で行って, コードが変化したなら, またその三つの最適化をかける. コードが変化していないなら, その三つの最適化を終了し, レジスタ割り付けを行うようになっている.
\subsection{感想}
思ったより大変だった. コピー伝搬は, 元々到達可能コピー解析の結果を用いて行っていたのだが, 割と終盤になってから到達可能コピー解析が上手く行っていないことに気付き焦った. しかし, よく考えると到達可能コピー解析は到達可能定義解析の特別な場合だと気付いたので, それを用いてコピー伝搬を実装できた(2が付いているのはそのため). 逆にそう考えると到達可能コピー解析って要らないのではないかとも思った. 特に今回の実験では到達可能コピー解析は到達可能定義解析よりも難易度が高く(共通部分を取る必要があるので), いよいよ必要性を感じなかった. また, 今回の最適化は, 元々のプログラムを最適化するというよりは, コンパイラが変換していく過程で生まれた無駄をなくすといった風に感じた. なぜなら, 普通のプログラムにおいてこれらの最適化が働くとしたら, 定数に名前付けている場合ぐらいだと思ったからだ. 例えば, ifの削除なんて, そもそも静的な解析で削除できるようなifなんて書くなという話になる. 何はともあれ, 最適化が上手くいって, 関数呼び出しのないプログラムがretのみになるのはわくわくして, たいへん面白かった.


\section{全体の感想}
面白かった. 各課題については, 資料に書いてある通りに実装するだけみたいな簡単なのもあれば, ほとんどヒントがないものもあって, 難易度にばらつきがあると感じた. 特に, アセンブリに変換する部分は親切過ぎる気もした(ありがたかったが). また, 最後のデモ用のプログラムを動かそうとして初めて気付いたバグが多く(周りの人もそのように見受けられた), 短期間でそれを直さなければならないのは中々酷だと思った. 中間レポートで問題ないと言われたクロージャの部分に微妙にバグが見つかったりして, やはりテストコードが欲しいと思った. 最後に, 関数間の最適化なしのこれ以上最適化を行うなら, mls命令を使ったりmovlt命令を使ったりするなど, 一般的な最適化というよりは, よりARMに特化したことを行う必要があると感じた.
\end{document}
