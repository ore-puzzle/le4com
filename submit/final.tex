\documentclass{jarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\usepackage{listings}

\begin{document}

\title{最終レポート}
\author{1029289895 尾崎翔太}
\date{2018/11/}

\maketitle
\newpage

\section{課題8}
\subsection{プログラムの設計方針}
基本的には末永先生の教科書通りになっている. 教科書にないものについては実験のページに書いてある通りにした. そのため, 設計方針について特筆すべきことはない.
\subsection{プログラムの説明}
vm.mlに定義されている関数のいくつかについて説明する.
\subsubsection{gather\_id\_from\_exp関数(99〜115行目)}
exp中の変数のidを集める関数である. 最早自由変数は存在しないので, LetExpとLoopExpのみに注目すればよい. さらに, 同名の変数はリネームしてあるので重複もない. 集めた変数は関数δを構築するために使われる.
\subsubsection{make\_delta関数(119〜131行目)}
関数δを構築する関数である. 引数はParamと, 変数はLocalと関連付けていく. ただし, Localは関数の返り値を格納するものをt0とするため, indexは1からとする. 最後にList.assoc関数を仕込むことで関数δが完成する.
\subsubsection{fresh\_label関数(134〜142行目)}
IfExpやLoopExpの変換のためにフレッシュなラベルを得る関数である. 中身は実験3のfresh\_tyvar関数をまねている.
\subsubsection{trans\_value関数(148〜152行目)}
Flat.valueを変換する関数である. Varはdeltaにより適切な格納領域に変換される.
\subsubsection{trans\_cexp関数(159〜188行目)}
Flat.cexpを変換する関数である. 教科書通りである. loop\_varとlblはtrans_exp関数のための引数である. 
\subsubsection{trans\_exp関数(193〜213行目)}
Flat.expを変換する関数である. CompExpとLetExpは教科書通りである. LoopExpはLetExpに似ているが, ラベルを生成していたり, delta関数を二回呼んでいたりしている部分が違う. これらの情報はRecurExpを変換するのに必要となるため, trans\_exp関数はこれらも引数に取るようになっている. RecurExpはそれらの情報から, 更新された値をどこに格納するか, そしてどこにジャンプするかを決める.
\subsection{感想}
基本的に教科書通りに実装することができた. ここまではtrans\_value関数みたいな関数は関数内関数ではなくて, 外に置いていたが, 今回はproc\_nameが欲しかったので中に置くことになり, 微妙に一貫性が取れていない. loop\_varやlblみたいな, 一部でしか使わない値を引数として持ちまわるのは正しいのかどうか, いまだによくわかっていない. いずれにせよ, 教科書のおかげで実装方針が明確だったので, そこまで苦労しなかった.


\section{課題9}
\subsection{プログラムの設計方針}
実験のページに載っている部分はそのまま実装した. 載っていない部分として, ARMにおける即値の取り扱いがある. 調べたところ, ARMの即値は8ビットの値をローテートシフトを行うことで生成しているようだ. したがって, 例えば277(100010101)のように, 1が立っている範囲が8ビットに収まっていないとエラーが出る. そのかわりに, ldrの第二引数に=プレフィックスをつけることで定数のロードができるようである. ゆえに, 仮想機械コードをARMアセンブリコードに変換した後で, ARMで取り扱えない即値があるならldr命令を用いたものに置き換えるということをする.
\subsection{プログラムの説明}
arm_noreg.mlに定義されている関数のいくつかについて説明する.
\subsubsection{make\_instr\_of\_malloc関数(43〜55行目)}
Mallocにおいて値をヒープ領域に格納する命令列を生成する関数である. ヒープ領域の先頭アドレスを保持しているレジスタがA1であることを仮定しており, A1にmem\_accessしている. ただし, 格納したい値がmymallocを呼ぶ前のA1に入っていた場合は, それを一旦退避先から適当なレジスタに読みだして格納している.
\subsubsection{to\_binary\_str関数(58〜67行目)}
int型の値を2進数表示のstring型の値に変換する関数である. 具体的には, 0か1のみが格納されているリストで, 引数の2進表現を行って, stringにマップし, fold\_leftで結合している. この関数はimm\_to\_ldr関数で用いられる.
\subsubsection{get\_max\_range関数(70〜76行目)}
与えられた2進数(string型)の一番左の1と一番右の1との間隔を返す関数. string型で与えられているので, 簡単に求めることができる. ただし, すべて0の場合のエラー処理には注意しなければならない. この関数はimm\_to\_ldr関数で用いられる.
\subsubsection{imm\_to\_ldr関数(81〜100行目)}
不適切な即値を用いているMov, Add, Cmpをldrを使ったものに変換する関数である. MovはそのままLdrに変換して, Add, Cmpは一旦A4にldrしてから演算している. また, =プレフィックスをつけるために, 意味的には不適切だが, addrのLコンストラクタを用いている. 引数がリストの形をしているのは, 一つの命令を二つの命令に変換するためである.
\subsubsection{gen\_instr関数(109〜165行目)}
実際に変換を行う関数である. 実験のページの変換そのものである.
\subsubsection{gen\_decl関数(107〜180行目)}
命令列を生成する関数である. 167行目は, gen\_instr関数を用いて仮想機械コードをARMアセンブリコードにマップして(stmt list list), concatして(stmt list), その要素一つ一つをそれだけからなるリストにマップして(stmt list list), imm\_to\_ldr関数でマップして(stmt list list), concatしている(stmt list). imm\_to\_ldr関数は命令数を変えうる変換をするので, わざわざリストのリストにしている.
\subsection{感想}
実験のページに変換方法がほぼ全て書いてあったのでとても簡単だった. 一方で, mymallocは引数を一つしか取らないが, A2もちゃんと退避しなければならなかったり, ARMの即値の仕様が複雑だったりと, わかりづらい落とし穴だらけで, できたと思うところまでは楽だが, 後になって原因不明のバグに苦しめられる部分だったと思った.


\section{課題11}
\subsection{前置き}
到達定義解析のみを行った. 
\subsection{プログラムの設計方針}
コンパイラの講義スライドの内容をlive.mlをまねて実装した. プロパティは変数とそれが定義された行番号ということだったので, 行番号に相当するものを得るためにcfgを受け取ることにした. また, 変数はリネームしてあり同名の変数を複数回定義するのはループの場合だけなので, kill関数は存在しない. 
\subsection{プログラムの説明}
reachableDef.mlに定義されている関数のいくつかを説明する.
\subsubsection{get\_second\_list関数(35〜38行目)}
二要素の組からなるリストから, 第二要素のみからなるリストを作る関数である. 受け取ったcfgは, 実は関数名とcfgの組になっているので, いらない関数名を捨てるための関数である.
\subsubsection{transfer関数(43〜55行目)}
伝達関数である. gen関数は, 変数に値を格納する命令の場合に, その変数のidとその命令のcfg中での位置の組を生成する. 上で述べたように, 同じ変数を複数回定義するのはループの場合のみで, その場合も再定義した直後にループの先頭という, 元の定義も到達しうる場所に戻るので, kill関数は必要ない.
\subsection{感想}
MiniMlが関数型言語であることと, 正規化の段階で変数名の付け替えを行ったことが幸いして, かなり単純になっている. 難しいのは解析そのものではなく, スライドの行番号にあたるものをどうやって得るかであった. ここまでできるだけ参照は使わないようにしていたのだが, cfgを利用するための他の方法が思いつかなかったので泣く泣く参照を使用した.

\section{課題12}
\subsection{プログラムの設計方針}
実験のページにあるように干渉グラフを用いてレジスタ割り付けをすることにした. 干渉グラフの彩色については, いわゆる貪欲法を採用した. つまり, 頂点を何らかの順で並べておき, その順に色を塗っていく. 色は0, 1, 2, ・・・, で表されていて, 今塗ろうとしている頂点に隣接している頂点に使われていない色の中で, 最も値が小さい色を塗るという方法だ. 頂点の順番は次数によるのがよいことは明らかだが, 昇順と降順のどちらにするかは思想による. 今回は, できるだけ多くの変数をレジスタに割り当てるということだったので, 次数の大きい頂点(多くの変数と共に生存している変数)がレジスタに居られると邪魔であるから, 昇順にすることにした. こうして色を塗ったあとで, 実際に使えるレジスタの数番目の色までをレジスタに, それ以降の色をローカル領域に割り当てた. コード生成については, Mallocの第二要素の要素がローカル領域に割り付けられている場合に, Mallocをさらに細分化しないと実装できないので, MallocをMallocとAssignの二つに分割した. Mallocではヒープ領域の確保のみを行って, Assignで格納していく. 他には, ローカル領域からの読み出しに用いたりする一時レジスタとしてreserved\_regを使用した. また, 関数呼び出しの際にレジスタを退避する必要があるが, すべてのレジスタを退避するのではなく, 本当に対比しなければならないレジスタのみを退避している. 最後に, どうしてもレジスタが足りない場合のために, ローカル領域に一つだけ退避する場所を作った.
\subsection{プログラムの説明}
reg.mlに定義されている関数のいくつかを説明する.
\subsubsection{get\_properties\_as\_list関数(165〜172行目)}
すべての命令の前後のプロパティをまとめてリストとして得る関数である. Dfa.get\_property関数を呼んで結合していくだけだが, ラベルにはプロパティがないことだけ注意する必要がある.
\subsubsection{trans\_props\_from\_op\_to\_id関数(175〜181行目)}
プロパティにはParamとLocalがあるのだが, Paramは捨ててLocalにぶら下がっているidを取り出す関数である. レジスタ割り付けにパラメータの情報は必要なく, どのLocalが生存しているかが重要なので, いちいちLocalからidを取り出すのも面倒だという要望を叶えるのに用いる. ただし, プロパティには不動点反復を回すためのdummyが紛れているので, それも弾くようにしている.
\subsubsection{make\_adjacency\_matrix関数(185〜216行目)}
隣接行列を作る関数である. まず, 大きさがVmにおける局所変数の数で, すべての要素が0の正方行列を表す配列を作る(idの値がそのまま行, 列に対応している). そして, 変数の生存情報を見ながら行列を更新していく. outer\_loopでは生存している変数の集合を順に取り出してinner\_loopへ渡していく. inner\_loopでは, 先頭の要素を取り出して, 残りの要素たちと行列において交わる部分の値を1に更新していく. また, MallocがMallocとAssignに分かれたことによる干渉は当然生存変数解析で解析されていないので, ここで行っている. 
\subsubsection{get\_max関数(246〜250行目)}
リスト中の最大値を返す関数である. この関数はある頂点に隣接している頂点に塗られている色の最大値を求めるために用いる. その頂点には返り値+1の色を塗れば良いのだ. こうすると, 例えば周りの頂点の色が0と2だったら1ではなく3を塗ってしまうではないかと思われるが, 塗ろうとしているのは一般のグラフではなく干渉グラフで, かつ次数でソートしてあるため, そのようなことは起こらない.
\subsubsection{map\_property関数(283〜290行目)}
プロパティを割り付けの結果にマップする関数(Paramとローカル領域に割り付けられたものは無視)である.　今使われているレジスタを知りたい時に用いる.
\subsubsection{get\_max\_tmp関数(293〜302行目)}
各関数呼び出しにおいて退避すべきレジスタの数, の最大値を返す関数である. 退避のためのローカル領域の大きさを得るために用いる.　関数呼び出し(Call)の直後で生存しているレジスタから, その返り値が格納されるレジスタを除いたものが退避すべきレジスタであるから, その数を見ていけばよい.
\subsubsection{make\_regs関数(312〜319行目)}
汎用レジスタのリストを返す関数である. 今使用可能なレジスタを得るために全体集合のようなものが必要だったので定義した.
\subsubsection{paint関数(325〜338行目)}
頂点に色を塗っていく関数である. 一つずつ頂点を見ていくためにあるのがnow\_node\_colorで, 隣接している頂点の色を知るために頂点全体を保持しているのがnode\_colorである. 隣接行列の対応する行を取り出して, その情報から隣接している頂点がわかるので, それらの頂点の色を集めて, dummy(-1)を加えたものの最大値+1の色で塗る. node\_colorも更新していく.
\subsubsection{make\_map関数(341〜355行目)}
塗られた頂点から, 実際にレジスタ割り付けを行っていく関数である. 塗られた色が汎用レジスタの数より小さければレジスタに, そうでなければローカル領域に割り付ける. 返り値には, そうしてできたマップの他に, 必要なローカル領域の数も含まれる. 一つでもローカル領域に割り付けられた場合は, 退避のために追加で一つローカル領域を確保する. 実際には,　ローカル領域に割りつけられたものが一つだけなら退避のための領域は必要ないのだが, その後の処理を簡単にするために一つだけの場合も退避する領域を確保している.
\subsubsection{make\_call\_instr関数(364〜502行目)}
Callを変換する関数である. Callは場合分けしなければならない引数が実質3つある上に, さらにそれぞれの場合の中でも場合分けがあるので大量の場合分けが発生している. 関数化しようにも, 部分部分のコード量は少ないのに微妙に異なっていることが多いので, コード量はあまり減りそうになかった. 場合分けが多いだけで, それぞれの場合でしていることは単純なので,　丁寧に追っていくと理解するのは難しくないと思う. 基本的に, reserved\_reg, 空いているレジスタ, 退避したレジスタの順に利用していく. 空いているレジスタと退避したレジスタの関係から, 空いているレジスタがないときは必ず退避したレジスタがあるので上手くいくようになっている.
\subsubsection{trans\_instr関数(506〜597行目)}
実際にコードを変換する関数である. 基本的にはreserved\_regを用いてローカル領域の読み書きを行っている. BinOpはmake\_call\_instr関数のように場合分けを列挙しても良かったのだが, 上手くまとめてみたかったのでこういう形になった. ローカル領域に作った退避のための空間が使われ得るのはBinOpの場合だけである. 
\subsubsection{trans\_intstrs関数(601〜613行目)}
順番にtrans\_instr関数を呼んでいく関数である. List.map関数を用いずに再帰関数で書いているのは, available\_regを求めるために, 変換しようとしている命令の直前のプロパティが必要だからである.
\subsection{感想}
グラフ彩色の方針は簡単に定まったが, それを実装するのに苦労した. グラフの部分はもっと汎用なものにして別ファイルにまとめようかと思ったが, この実験では他に使わないので, 面倒くさくなって, 結局この課題にべったり依存した形になった. 変換の部分は, 本質的には単純だが, とにかく場合分けが多くて大変だった. BinOpも最初はCallのように場合分けを列挙していたのだが, 上手くまとめる方法を模索している内にああなった. 正直場合分けを列挙している方がわかりやすい気がする. ここまで場合があると, すべての場合に正しく動作していることを確認するのは相当大変だと思った. 実際私はしていない.　また, Mallocについては, 元の仕様より私の仕様の方が自然だと思うのだがどうなのでしょうか. それと, MallocとReadだけdestを用いている(Assignもそれにならった)理由がよくわからなかった. メモリからメモリに移動させる命令でもあれば話は違うのだが.　更に上を目指すなら, この段階ではレジスタ割り付けをしてどれだけのローカル領域か必要かだけを得て, コード自体はレジスタが無限にあるとして,　ローカル領域のやりとりはすべてARMアセンブリコードを吐くところでやった方が, 見えているレジスタの数が違うので, より良くなると思った.


\section{課題13}
\subsection{プログラムの設計方針}
やることはレジスタ割り付けなしの場合とほとんど同じなので, 基本方針も同じである. 違う点として, 即値を読みだすレジスタをどうするかというものがあるが, A3を使うことにした. また, いくつかの場合で, さらに一時レジスタが欲しくなったときは, A4を使うことにした.
\subsection{プログラムの説明}
arm_reg.mlに定義されている関数の一つを説明する.
\subsubsection{gen\_instr関数(111〜207行目)}
実際にコードを生成する関数である. 基本的にはarm\_noreg.mlにあるものと同じである. 大きく違うのは, BinOpとMalloc, Assignである. BinOpはaddrとして即値も取るようになったので, そこで場合分けをしている. 例外として, Multの第二引数が即値だった場合は一旦A4に読みだしていたり, Cmpの非可換性から値をA3に読みだしたりしている. 実は最適化によりliは要らないのだが, 必ずしも最適化するわけではないので残している. Mallocについては, mymallocを呼び出して返り値を格納すべき場所に格納するまでを行い, そのヒープ領域に値を格納していくのはAssignで行っている. その際, destがローカル領域に割り付けられていた場合はAssignのたびに読みだしている.
\subsection{感想}
BinOpが意外とややこしい感じになってしまった. これもあまり変に共通部分をまとめずに, Add, Mult, Cmpで始めに場合分けをした方が見通しが良かったかもしれない. Malloc/Assignについてはレジスタ割り付けなしの場合のように, A1にポインタがあると仮定して, 第一引数を格納したい場合だけ例外処理をしたかったが, Assignがいつ終わるかわからないと, 退避したA1とA2を書き戻せないのでできなかった. 実はこれを実現するためにgen\_instr関数をList.map関数ではなく, 再帰関数で呼び出すようにしようと思っていたのだが, 今の今まで忘れていた.


\section{課題14}
\subsection{プログラムの設計方針}
(a), (b), (c)すべて行った. アイデア自体はコンパイラのスライドそのものである. コピー伝搬は, (到達可能コピー解析ができていないので)到達可能定義解析から, 使われようとしている変数の定義がParam, あるいはLocalのMoveだった場合に置き換えることで実装している. 解析結果はcfgにおける位置情報なので, cfgそのものも受け取る必要がある. 伝搬させていくためには, 置き換えた場合に, cfgの方の命令も置き換えたものに変えていく必要があるのでそうしている. 定数畳み込みは, コピー伝搬と同様の考えで, Param, Localの部分がProc, IntVになっただけである. ただし, BinOpはもう一歩踏み込んで, 未知変数一つと定数二つが同じ演算子で結ばれている場合も計算するようになっている. また, 畳み込みは一つずつ行われる. 定数の畳み込みが終わったあとで, if文が除去できるなら除去している. したがって, 定数畳み込みは複数回行うことを想定している. 不要代入文削除は, 生存変数解析から, 定義された直後に生存していない変数を定義している文を除去している. これらの最適化を, コード変化しなくなるまでずっと順に適用していく. 
\subsection{プログラムの説明}
\subsubsection{コピー伝搬}
\subsubsubsection{xxx関数}

\end{document}
