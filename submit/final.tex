\documentclass{jarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\usepackage{listings}

\begin{document}

\title{最終レポート}
\author{1029289895 尾崎翔太}
\date{2018/11/}

\maketitle
\newpage

\section{課題8}
\subsection{プログラムの設計方針}
基本的には末永先生の教科書通りになっている. 教科書にないものについては実験のページに書いてある通りにした. そのため, 設計方針について特筆すべきことはない.
\subsection{プログラムの説明}
vm.mlに定義されている関数のいくつかについて説明する.
\subsubsection{gather\_id\_from\_exp関数(99〜115行目)}
exp中の変数のidを集める関数である. 最早自由変数は存在しないので, LetExpとLoopExpのみに注目すればよい. さらに, 同名の変数はリネームしてあるので重複もない. 集めた変数は関数δを構築するために使われる.
\subsubsection{make\_delta関数(119〜131行目)}
関数δを構築する関数である. 引数はParamと, 変数はLocalと関連付けていく. ただし, Localは関数の返り値を格納するものをt0とするため, indexは1からとする. 最後にList.assoc関数を仕込むことで関数δが完成する.
\subsubsection{fresh\_label関数(134〜142行目)}
IfExpやLoopExpの変換のためにフレッシュなラベルを得る関数である. 中身は実験3のfresh\_tyvar関数をまねている.
\subsubsection{trans\_value関数(148〜152行目)}
Flat.valueを変換する関数である. Varはdeltaにより適切な格納領域に変換される.
\subsubsection{trans\_cexp関数(159〜188行目)}
Flat.cexpを変換する関数である. 教科書通りである. loop\_varとlblはtrans_exp関数のための引数である. 
\subsubsection{trans\_exp関数(193〜213行目)}
Flat.expを変換する関数である. CompExpとLetExpは教科書通りである. LoopExpはLetExpに似ているが, ラベルを生成していたり, delta関数を二回呼んでいたりしている部分が違う. これらの情報はRecurExpを変換するのに必要となるため, trans\_exp関数はこれらも引数に取るようになっている. RecurExpはそれらの情報から, 更新された値をどこに格納するか, そしてどこにジャンプするかを決める.
\subsection{感想}
基本的に教科書通りに実装することができた. ここまではtrans\_value関数みたいな関数は関数内関数ではなくて, 外に置いていたが, 今回はproc\_nameが欲しかったので中に置くことになり, 微妙に一貫性が取れていない. loop\_varやlblみたいな, 一部でしか使わない値を引数として持ちまわるのは正しいのかどうか, いまだによくわかっていない. いずれにせよ, 教科書のおかげで実装方針が明確だったので, そこまで苦労しなかった.


\section{課題9}
\subsection{プログラムの設計方針}
実験のページに載っている部分はそのまま実装した. 載っていない部分として, ARMにおける即値の取り扱いがある. 調べたところ, ARMの即値は8ビットの値をローテートシフトを行うことで生成しているようだ. したがって, 例えば277(100010101)のように, 1が立っている範囲が8ビットに収まっていないとエラーが出る. そのかわりに, ldrの第二引数に=プレフィックスをつけることで定数のロードができるようである. ゆえに, 仮想機械コードをARMアセンブリコードに変換した後で, ARMで取り扱えない即値があるならldr命令を用いたものに置き換えるということをする.
\subsection{プログラムの説明}
arm_noreg.mlに定義されている関数のいくつかについて説明する.
\subsubsection{make\_instr\_of\_malloc関数(43〜55行目)}
Mallocにおいて値をヒープ領域に格納する命令列を生成する関数である. ヒープ領域の先頭アドレスを保持しているレジスタがA1であることを仮定しており, A1にmem\_accessしている. ただし, 格納したい値がmymallocを呼ぶ前のA1に入っていた場合は, それを一旦退避先から適当なレジスタに読みだして格納している.
\subsubsection{to\_binary\_str関数(58〜67行目)}
int型の値を2進数表示のstring型の値に変換する関数である. 具体的には, 0か1のみが格納されているリストで, 引数の2進表現を行って, stringにマップし, fold\_leftで結合している. この関数はimm\_to\_ldr関数で用いられる.
\subsubsection{get\_max\_range関数(70〜76行目)}
与えられた2進数(string型)の一番左の1と一番右の1との間隔を返す関数. string型で与えられているので, 簡単に求めることができる. ただし, すべて0の場合のエラー処理には注意しなければならない. この関数はimm\_to\_ldr関数で用いられる.
\subsubsection{imm\_to\_ldr関数(81〜100行目)}
不適切な即値を用いているMov, Add, Cmpをldrを使ったものに変換する関数である. MovはそのままLdrに変換して, Add, Cmpは一旦A4にldrしてから演算している. また, =プレフィックスをつけるために, 意味的には不適切だが, addrのLコンストラクタを用いている. 引数がリストの形をしているのは, 一つの命令を二つの命令に変換するためである.
\subsubsection{gen\_instr関数(109〜165行目)}
実際に変換を行う関数である. 実験のページの変換そのものである.
\subsubsection{gen\_decl関数(107〜180行目)}
命令列を生成する関数である. 167行目は, gen\_instr関数を用いて仮想機械コードをARMアセンブリコードにマップして(stmt list list), concatして(stmt list), その要素一つ一つをそれだけからなるリストにマップして(stmt list list), imm\_to\_ldr関数でマップして(stmt list list), concatしている(stmt list). imm\_to\_ldr関数は命令数を変えうる変換をするので, わざわざリストのリストにしている.
\subsection{感想}
実験のページに変換方法がほぼ全て書いてあったのでとても簡単だった. 一方で, mymallocは引数を一つしか取らないが, A2もちゃんと退避しなければならなかったり, ARMの即値の仕様が複雑だったりと, わかりづらい落とし穴だらけで, できたと思うところまでは楽だが, 後になって原因不明のバグに苦しめられる部分だったと思った.


\section{課題11}
\subsection{前置き}
到達定義解析のみを行った. 
\subsection{プログラムの設計方針}
コンパイラの講義スライドの内容をlive.mlをまねて実装した. プロパティは変数とそれが定義された行番号ということだったので, 行番号に相当するものを得るためにcfgを受け取ることにした. また, 変数はリネームしてあり同名の変数を複数回定義するのはループの場合だけなので, kill関数は存在しない. 
\subsection{プログラムの説明}
reachableDef.mlに定義されている関数のいくつかを説明する.
\subsubsection{get\_second\_list関数(35〜38行目)}
二要素の組からなるリストから, 第二要素のみからなるリストを作る関数である. 受け取ったcfgは, 実は関数名とcfgの組になっているので, いらない関数名を捨てるための関数である.
\subsubsection{transfer関数(43〜55行目)}
伝達関数である. gen関数は, 変数に値を格納する命令の場合に, その変数のidとその命令のcfg中での位置の組を生成する. 上で述べたように, 同じ変数を複数回定義するのはループの場合のみで, その場合も再定義した直後にループの先頭という, 元の定義も到達しうる場所に戻るので, kill関数は必要ない.
\subsection{感想}
MiniMlが関数型言語であることと, 正規化の段階で変数名の付け替えを行ったことが幸いして, かなり単純になっている. 難しいのは解析そのものではなく, スライドの行番号にあたるものをどうやって得るかであった. ここまでできるだけ参照は使わないようにしていたのだが, cfgを利用するための他の方法が思いつかなかったので泣く泣く参照を使用した.

\section{課題12}
\subsection{プログラムの設計方針}

\subsection{プログラムの説明}


\section{課題13}
\subsection{プログラムの設計方針}

\subsection{プログラムの説明}


\section{課題14}
\subsection{プログラムの設計方針}

\subsection{プログラムの説明}