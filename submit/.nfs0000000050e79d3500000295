\documentclass{jarticle}
\usepackage[dvipdfmx]{graphicx}
\usepackage{here}
\usepackage{listings}

\begin{document}

\title{中間レポート1}
\author{1029289895 尾崎翔太}
\date{2018/10/18}

\maketitle

\section{課題2}
\subsection{プログラムの設計方針}
この課題は至極単純なので, 設計方針は資料に書いてある通りに実装することである.

\subsection{プログラムの説明}
\subsubsection{lexer.mll}
Loop式のための"loop"とRecur式のための"recur"を予約語に追加した. また, 組のために","と"."も認識できるようにした.

\subsubsection{parser.mly}
与えられたBNFをそのまま実装しただけで, 特に説明することはない.

\subsection{感想}
これは実験３をやっていれば難しいところは一つもなく, コードする量も少なかったので, 肩慣らしだなと思った.


\section{課題4}
\subsection{プログラムの設計方針}
「末尾位置ならば・・・」という文言があるので, 今処理しようとしているノードが末尾位置にあるかどうかを表す変数を用意した. 後は木を巡回してRecurExpを見つけた時に末尾位置にあるかどうかを見れば良い.

\subsection{プログラムの説明}
syntax.mlの25〜50行目にrecur\_check関数がある. 実体は26〜48行目のbody\_loop関数で, この関数はexpに加えて, 今末尾位置にいるかどうかを表すbool型のis\_endを引数に取る.　一番トップレベルは末尾位置ではないので, 最初body\_loopはfalseで呼び出される. RecurExpを探すので, expが子にないノードは何もしない. また, expでない子に対しても何もしない. expを子に持つノードは, 末尾位置の定義に従ってその子が末尾位置にあるかどうかを判断して, is\_endを適切な値にしてbody\_loop関数を呼び出す. そして, RecurExpを処理する際にis\_endがfalseならばエラーを吐くようになっている.

\subsection{感想}
末尾位置の定義を見て素直に実装するとこうなると思う. is\_endを使い回すことでif式はRecurExpの場合にしか現れず, 全体的にすっきりした.


\section{課題5}
\subsection{プログラムの設計方針}
はじめは素直に実装していたのだが, 無駄なLet束縛を無くさないと後の課題の中間表現が読みにくいことに気づいたので, そうすることにした. この部分に関しては, 資料の付録の通りに実装することにした. しかし, それで上手く行ったのはIfExpだけで, BinOpとAppExpについては試行錯誤することになった. また, 無駄なLet束縛を無くしたことで, 変換前後でプログラムの意味が変わってしまう場合があったので, それを防ぐために前処理を行うことにした. この前処理はnorm\_expの中で行うこともできなくはなかったが, 正規形にするという本質から外れているのでそうしなかった. 結果として, 変換に2パスかかってしまったがご容赦願いたい.

\subsection{プログラムの説明}
\subsubsection{前処理部}
normal.mlの103〜127行目のrename関数と130〜158行目のpreprocess関数で行う. rename関数はexpとidを受け取って, exp中のidをすべて同じフレッシュなidに置き換える. このフレッシュなidは元のidの頭に"\$"を付けるようにしたfresh\_id関数で作る. また, 一度リネームしたものをもう一度リネームすると"\$"と数字がどんどん付いて行くので, それを防ぐために105行目で先頭と最高尾の文字を削ってからfresh\_idをしている. preprocess関数はexpと束縛されたidを保持するid\_listを引数に取る. LetExpあるいはLetRecExpを見つけると, それが束縛しようとしているidがid\_listに含まれているかどうかを調べて, そうならこのLetExpあるいはLetRecExpにrename関数を適用して新しくなったidをid\_listに追加する. そうでないなら, そのままidをid\_listに追加する. 全体としては226行目でpreprocess関数を呼び出すことで前処理を行う.

\subsubsection{正規化部}
normal.mlの96〜100行目のｖｋ関数は資料の\mathcal{V}_{k}を表しており, そのまま実装してある. 正規化の本体は163〜220行目のnorm\_exp関数である. ｆは資料の付録のvalueをcexpに変えただけといった使い方をしている. ただ, 上から渡されたfをそのまま下に渡すかどうかは判断しなければならない. 無駄なLet束縛を無くすことはIfExpでは自然な実装になっている. BinOp, AppExp, TupleExpは無駄なLet束縛を無くしたい部分が二箇所あるので, 片方はｖｋ関数なしで処理して, もう片方はその結果を利用してｖｋ関数を用いて処理している. 

\subsection{感想}
急に難易度が上がったと感じた. プログラムの説明においてｆの使い方が微妙に曖昧なのは, きちんと理解して書いたというよりは試行錯誤の結果こうすればいいとわかったからである. 無駄なLet束縛の排除については, BinOp, AppExp, TupleExpは苦労したし, コードも気持ち悪い感じになってしまった. とはいえｖｋ関数にまかせてしまうと, その中で作られたフレッシュなidを得ようとすると大変なのでこういうやり方ですることにした. それと, テストがないのが辛いと感じた. 先へどんどん進めたくなって, 資料と同じようなコードを吐けばそれでいいやという気持ちになり, 変なケースを考えられない. 正直今のプログラムが本当にきちんと動いているかは余り自信がない.


\end{document}
